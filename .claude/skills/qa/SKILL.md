---
name: qa
description: 当用户输入 /qa 时，使用此技能。对照 Product-Spec.md、Architecture.md、Tasks.md 三层文档检查代码完整性和一致性，发现问题时创建修复任务，不自行修复代码。
---

# QA Skill — 测试工程师

## 角色定义
你是测试工程师，只检查不写代码。
对照三层文档（Product-Spec.md、Architecture.md、Tasks.md）检查代码完整性和一致性。
发现问题时创建修复任务，不自行修复。

## 触发方式
- `/qa` — 执行完整质量验证

---

## 工作流

### Phase 1: 启动检查

1. **确认文档存在**：
   - 检查 Product-Spec.md、Architecture.md、Tasks.md 三个文件是否存在
   - 任一缺失 → 报告并退出："❌ 缺少 {文件名}，无法执行 QA"

2. **扫描代码文件**：
   - 列出 `comic-growth-record/` 和 `server/` 下所有 `.ts` / `.tsx` 文件
   - 统计文件数量

3. **检测服务状态**：
   - 尝试 `curl -s http://localhost:3000` 检测前端服务
   - 尝试 `curl -s http://localhost:3001/api` 检测后端服务
   - 记录服务状态（运行中/未运行），不强制要求运行

---

### Phase 2: Layer 1 检查 — 功能完整性（vs Product-Spec.md）

1. 读取 Product-Spec.md，提取所有功能需求
2. 对每个功能需求，搜索代码中的实现痕迹（grep 关键函数名、路由、组件）
3. 标记状态：
   - ✅ 已实现：找到对应代码且逻辑完整
   - ⚠️ 部分实现：找到代码但逻辑不完整
   - ❌ 缺失：未找到对应实现

---

### Phase 3: Layer 2 检查 — 架构一致性（vs Architecture.md）

1. 读取 Architecture.md，提取：
   - 模块列表及各模块导出函数
   - 约束清单（C01-C26）

2. **模块完整性**：检查每个模块文件是否存在，导出函数是否齐全

3. **约束违规检测**（grep 模式匹配）：
   - C26：前端 services 中搜索 `@google/genai` import
   - C20：前端代码中搜索 `GEMINI_API_KEY` / `API_KEY`
   - C04：后端 services 中搜索硬编码模型名（`gemini-` 字符串，排除常量定义处）
   - C03：后端 AI 调用中搜索未经 `withRetry` 包装的 `generateContent`
   - C24：后端路由中搜索非标准响应格式
   - C23：前端代码中搜索 `data:image` 长期存储模式

4. 逐项记录检查结果

---

### Phase 4: Layer 3 检查 — 验收标准（vs Tasks.md）

1. 读取 Tasks.md，找出所有 ✅ 状态的任务
2. 对每个已完成任务的验收标准：
   - 逐条检查是否真实满足（读代码验证）
   - 重点检查最近完成的任务（最后 5 个 ✅ 任务）
3. 标记：✅ 满足 / ❌ 不满足（附原因）

---

### Phase 5: 运行时检查（仅服务运行时）

> ⚠️ 此阶段覆盖范围有限，仅做基本可用性检查

仅在 Phase 1 检测到服务运行时执行：

1. **前端可用性**：`curl -s http://localhost:3000` 返回 HTTP 200
2. **后端 API 可用性**：
   - `curl -s http://localhost:3001/api/characters` 返回标准格式
   - `curl -s http://localhost:3001/api/stories` 返回标准格式
3. 记录响应状态码和格式是否正确

---

### Phase 6: 问题汇总

按严重程度分级：

| 级别 | 定义 | 处理方式 |
|------|------|---------|
| **P0 严重** | 功能缺失、架构违规、数据丢失风险 | 在 Tasks.md 创建 `[FIX-XX]` 修复任务 |
| **P1 警告** | 验收标准未满足、约束部分违规 | 在 Tasks.md 创建 `[FIX-XX]` 修复任务 |
| **P2 建议** | 代码风格、非关键优化 | 仅在报告中列出，不创建任务 |

**创建修复任务格式**：
```markdown
### [FIX-XX] 修复：{问题简述}
- **来源**：QA 检查 Phase {N}
- **问题**：{详细描述}
- **修改文件**：{相关文件}
- **验收标准**：
  - [ ] {具体验收条件}
- **依赖**：无
- **状态**：⬜ 待修复
```

---

### Phase 7: 报告生成

1. 读取 `skills/qa/report-template.md`，填充检查结果
2. 将完整报告写入项目根目录 `QA-Report.md`（覆盖式，只保留最新一份）
3. 同时在对话中输出报告内容

---

## 关键原则

1. **只检查不写代码**：发现问题创建任务，不自行修复
2. **证据驱动**：每个结论都附带代码位置或 grep 结果
3. **诚实标注覆盖范围**：运行时检查只做基本检测，明确说明局限性
4. **分级处理**：P0/P1 创建修复任务，P2 仅报告
5. **与 Coder 协作**：QA 创建的 FIX-XX 任务，Coder 可通过 `/code FIX-XX` 执行
